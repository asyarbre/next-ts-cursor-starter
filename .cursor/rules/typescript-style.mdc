---
globs: *.ts,*.tsx
---

# TypeScript Coding Standards

## Type Definitions

- Use **interfaces** for object shapes that might be extended
- Use **type aliases** for unions, intersections, and computed types
- Use **PascalCase** for type names and interfaces
- Prefer explicit return types for functions
- Use **strict mode** settings (configured in [tsconfig.json](mdc:tsconfig.json))

```typescript
// Good
interface User {
  id: string
  name: string
}

type Status = 'pending' | 'completed' | 'error'

// Function with explicit return type
function getUser(id: string): Promise<User> {
  return fetch(`/api/users/${id}`).then(res => res.json())
}
```

## React Component Types

- Use **React.FC** sparingly, prefer explicit typing
- Use **PropsWithChildren** when components accept children
- Define prop interfaces inline for simple components
- Extract complex prop types to separate interfaces

```typescript
// Preferred approach
interface ButtonProps {
  variant: 'primary' | 'secondary'
  onClick: () => void
  children: React.ReactNode
}

function Button({ variant, onClick, children }: ButtonProps) {
  // implementation
}

// For pages with params/searchParams
interface PageProps {
  params: Promise<{ id: string }>
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>
}
```

## Import/Export Patterns

- Use **named exports** for utilities and hooks
- Use **default exports** for React components and pages
- Group imports: external libraries, internal modules, relative imports
- Use **type-only imports** when appropriate

```typescript
import type { Metadata } from 'next'
import { clsx } from 'clsx'

import { Button } from '@/components/ui/button'
import { cn } from '@/lib/utils'

import './styles.css'
```

## Error Handling

- Use proper TypeScript error types
- Implement type-safe error boundaries
- Use `unknown` for caught errors, then narrow the type

```typescript
try {
  // risky operation
} catch (error) {
  if (error instanceof Error) {
    console.error(error.message)
  }
}
```

## Next.js Specific Types

- Use `NextRequest` and `NextResponse` for API routes
- Use proper page prop types for App Router
- Leverage Next.js built-in types for metadata, layouts, etc.

## Path Aliases

Always use configured path aliases from [tsconfig.json](mdc:tsconfig.json):
- `@/components` instead of relative paths to components
- `@/lib/utils` for utility functions
- `@/hooks` for custom hooks